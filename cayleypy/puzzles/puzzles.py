from .cube import (
    rubik_cube_qstm,
    rubik_cube_htm,
    rubik_cube_qtm,
    rubik_cube_atm,
    fixed_corner_cub_quarter,
    fixed_corner_cub_half,
)
from .globe import globe_puzzle
from .hungarian_rings import hungarian_rings_generators
from .moves import MINI_PYRAMORPHIX_ALLOWED_MOVES, PYRAMINX_MOVES, MEGAMINX_MOVES
from .gap_puzzles import GapPuzzles
from ..cayley_graph_def import CayleyGraphDef
from ..permutation_utils import inverse_permutation


class Puzzles:
    """Definitions of graphs describing various puzzles."""

    @staticmethod
    def rubik_cube(cube_size: int, metric: str) -> CayleyGraphDef:
        """Cayley graph for NxNxN Rubik's cube.

        :param cube_size: - Size of the cube (N).
        :param metric: - metric defining what counts as one move, one of:
          - "QSTM" - Quarter Slice Turn Metric.
          - "QTM" - Quarter Turn Metric.
          - "HTM" - Half Turn Metric.
          - "ATM" - Axial Turn Metric.
          - "fixed_QTM" - fixed left corner with quarter turn moves (support only 2x2x2).
          - "fixed_HTM" - fixed left corner with half turn moves (support only 2x2x2).
        """
        if metric == "QSTM":
            return rubik_cube_qstm(cube_size)
        elif metric == "QTM":
            return rubik_cube_qtm(cube_size)
        elif metric == "HTM":
            return rubik_cube_htm(cube_size)
        elif metric == "ATM":
            return rubik_cube_atm(cube_size)
        elif metric == "fixed_QTM":
            return fixed_corner_cub_quarter()
        elif metric == "fixed_HTM":
            return fixed_corner_cub_half()
        else:
            raise ValueError(f"Unknown metric: {metric}")

    @staticmethod
    def globe_puzzle(a: int, b: int) -> CayleyGraphDef:
        """Cayley graph for Globe puzzle group, a + 1 cycle and 2b order 2 generators."""
        return globe_puzzle(a, b)

    @staticmethod
    def hungarian_rings(left_size: int, left_index: int, right_size: int, right_index: int) -> CayleyGraphDef:
        """Cayley graph for Hungarian rings puzzle group, generated by rotating two rings in both directions.

        :param left_size: - Left ring size.
        :param left_index: - Distance between intersections on the left ring. left_index <= left_size/2
        :param right_size: - Right ring size.
        :param right_index: - Distance between intersections on the right ring. right_index <= right_size/2
        """
        assert left_index <= left_size / 2
        assert right_index <= right_size / 2
        generators, generator_names = hungarian_rings_generators(left_size, left_index, right_size, right_index)
        n = len(generators[0])
        name = f"hungarian_rings-{left_size}-{left_index}-{right_size}-{right_index}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def mini_pyramorphix() -> CayleyGraphDef:
        """Cayley graph for a subgroup of S_24, acting on 24 titles.

        It is generated by 17 moves inspired by a simplified version of the Pyramorphix puzzle. Moves are based on
        overlapping 2- and 3-cycles and result in a symmetric, undirected graph.
        Order of the graph 24, degree 17, order of the group 288.
        """
        generator_names = list(MINI_PYRAMORPHIX_ALLOWED_MOVES.keys())
        generators = [MINI_PYRAMORPHIX_ALLOWED_MOVES[k] for k in generator_names]
        central_state = list(range(len(generators[0])))
        return CayleyGraphDef.create(generators, central_state=central_state, generator_names=generator_names)

    @staticmethod
    def pyraminx() -> CayleyGraphDef:
        """Cayley graph for a subgroup of S_36 acting on 36 tiles.

        It is generated by 8 elements inspired by Pyraminx puzzle.
        4 elements represent rotations of the tetrahedron tips, while 4 others -- rotations of its base layers.
        """
        generator_names = []
        generators = []
        for move_id, perm in PYRAMINX_MOVES.items():
            generators += [perm, inverse_permutation(perm)]
            generator_names += [move_id, move_id + "_inv"]
        central_state = list(range(len(generators[0])))
        return CayleyGraphDef.create(
            generators, central_state=central_state, generator_names=generator_names, name="pyraminx"
        )

    @staticmethod
    def starminx() -> CayleyGraphDef:
        """Cayley graph generated by 20 moves of Starminx puzzle.

        Each move is a rotation of a corner, centered around one of the dodecahedron’s pentagonal faces (face centres
        never move). A single turn corresponds to a set of disjoint 3-cycles, each on one triangular sticker.
        """
        return GapPuzzles.puzzle("starminx")

    @staticmethod
    def starminx_2() -> CayleyGraphDef:
        """Cayley graph associated with the Starminx 2 puzzle.

        Generated by 12 moves, corresponding to rotations of the whole dodecahedron’s faces (analogous to face turns
        in the Megaminx). Unlike the Starminx puzzle, where the generators are vertex-centered, the generators in
        Starminx 2 are face-centered and affect larger regions of the puzzle.
        """
        return GapPuzzles.puzzle("starminx_2")

    @staticmethod
    def megaminx():
        """Cayley graph for the Megaminx puzzle.

        See https://en.wikipedia.org/wiki/Megaminx.
        """
        generator_names = []
        generators = []
        for move_id, perm in MEGAMINX_MOVES.items():
            generators += [perm, inverse_permutation(perm)]
            generator_names += [move_id, move_id + "_inv"]
        central_state = list(range(len(generators[0])))
        return CayleyGraphDef.create(generators, central_state=central_state, generator_names=generator_names)
