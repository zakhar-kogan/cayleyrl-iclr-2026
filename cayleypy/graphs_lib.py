"""Library of pre-defined graphs."""

from itertools import permutations, combinations
from typing import Union
from math import factorial
import numpy as np

from .cayley_graph_def import CayleyGraphDef, MatrixGenerator
from .permutation_utils import (
    transposition,
    permutation_from_cycles,
    permutations_with_cycle_lenghts,
    partition_to_permutation,
    inverse_permutation,
)
from .puzzles.hungarian_rings import get_santa_parameters_from_n
from .puzzles.puzzles import Puzzles


def _create_coxeter_generators(n: int) -> list[list[int]]:
    return [transposition(n, k, k + 1) for k in range(n - 1)]


class PermutationGroups:
    """Pre-defined Cayley graphs for permutation groups (S_n)."""

    @staticmethod
    def all_transpositions(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n (n>=2), generated by all n(n-1)/2 transpositions."""
        assert n >= 2
        generators = []
        generator_names = []
        for i in range(n):
            for j in range(i + 1, n):
                generators.append(transposition(n, i, j))
                generator_names.append(f"({i},{j})")
        return CayleyGraphDef.create(generators, central_state=list(range(n)), generator_names=generator_names)

    @staticmethod
    def transposons(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n (n>=2), generated by transpositions of all possible substrings
        to all possible places."""
        assert n >= 2
        generators = []
        generator_names = []
        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j, n):
                    transp = list(range(i)) + list(range(j, k + 1)) + list(range(i, j)) + list(range(k + 1, n))
                    generators.append(transp)
                    generator_names.append(f"T[{i}..{j-1},{k}]")
        return CayleyGraphDef.create(generators, central_state=list(range(n)), generator_names=generator_names)

    @staticmethod
    def block_interchange(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n (n>=2), generated by interchanges of all possible pairs of substrings.
        https://arxiv.org/pdf/0811.0740"""
        assert n >= 2
        generators = []
        generator_names = []
        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j, n):
                    for l in range(k + 1, n + 1):
                        transp = (
                            list(range(i))
                            + list(range(k, l))
                            + list(range(j, k))
                            + list(range(i, j))
                            + list(range(l, n))
                        )
                        generators.append(transp)
                        generator_names.append(f"I[{i}..{j-1},{k}..{l-1}]")
        return CayleyGraphDef.create(generators, central_state=list(range(n)), generator_names=generator_names)

    @staticmethod
    def full_reversals(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n (n>=2), generated by reverses of all possible n(n-1)/2 substrings."""
        assert n >= 2
        generators = []
        generator_names = []
        for i in range(n):
            for j in range(i + 1, n):
                perm = list(range(i)) + list(range(j, i - 1, -1)) + list(range(j + 1, n))
                generators.append(perm)
                generator_names.append(f"R[{i}..{j}]")
        return CayleyGraphDef.create(generators, central_state=list(range(n)), generator_names=generator_names)

    @staticmethod
    def signed_reversals(n: int) -> CayleyGraphDef:
        """Cayley graph generated by reverses of all possible signed n(n+1)/2 substrings.

        Actually is a graph for S_2n (n>=1) representing a graph for n elements, where i-th index represents bottom
        side of i-th element, and (n+i)-th index represents top side of i-th element. The graph has n generators
        denoted R[1..1],R[1..2]..R[n..n], where R[i..j] is signed reverse of elements i,i+1..j
        (or actually indexes i..j,n+i..n+j).
        """
        assert n >= 1
        generators = []
        generator_names = []
        for i in range(n):
            for j in range(i, n):
                perm = []
                perm += list(range(i))
                perm += list(range(n + j, n + i - 1, -1))
                perm += list(range(j + 1, n))
                perm += list(range(n, n + i))
                perm += list(range(j, i - 1, -1))
                perm += list(range(n + j + 1, n + n))
                generators.append(perm)
                generator_names.append(f"R[{i}..{j}]")
        return CayleyGraphDef.create(generators, central_state=list(range(2 * n)), generator_names=generator_names)

    @staticmethod
    def lrx(n: int, k: int = 1) -> CayleyGraphDef:
        """Cayley graph for S_n (n>=3), generated by: shift left, shift right, swap two elements 0 and k.

        :param n: Size of permutations.
        :param k: Specifies that X is transposition of elements 0 and k. 1<=k<n.
            By default, k=1, which means X is transposition of first 2 elements.
        """
        assert n >= 3
        generators = [list(range(1, n)) + [0], [n - 1] + list(range(0, n - 1)), transposition(n, 0, k)]
        generator_names = ["L", "R", "X"]
        name = f"lrx-{n}"
        if k != 1:
            name += f"(k={k})"
        return CayleyGraphDef.create(
            generators,
            central_state=list(range(n)),
            generator_names=generator_names,
            name=name,
        )

    @staticmethod
    def lx(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n (n>=3), generated by left shift (L) and swapping first two elements (X).

        This is an example of a Cayley graph where generators are not inverse-closed.

        See https://oeis.org/A039745.

        :param n: Size of permutations.
        """
        assert n >= 3
        generators = [list(range(1, n)) + [0], transposition(n, 0, 1)]
        generator_names = ["L", "X"]
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=f"lx-{n}"
        )

    @staticmethod
    def top_spin(n: int, k: int = 4):
        """Cayley graph for S_n (n>=k>=2), generated by: shift left, shift right, reverse first k elements.

        :param n: Size of permutations.
        :param k: Specifies size of prefix to reverse. By default, k=4.
        """
        assert n >= k >= 2
        generators = [
            list(range(1, n)) + [0],
            [n - 1] + list(range(0, n - 1)),
            list(range(k - 1, -1, -1)) + list(range(k, n)),
        ]
        name = f"top_spin-{n}-{k}"
        return CayleyGraphDef.create(generators, central_state=list(range(n)), name=name)

    @staticmethod
    def coxeter(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n (n>=2), generated by adjacent transpositions (Coxeter generators).

        It has n-1 generators: (0,1), (1,2), ..., (n-2,n-1).
        """
        assert n >= 2
        generators = _create_coxeter_generators(n)
        generator_names = [f"({i},{i + 1})" for i in range(n - 1)]
        central_state = list(range(n))
        name = f"coxeter-{n}"
        return CayleyGraphDef.create(
            generators, central_state=central_state, generator_names=generator_names, name=name
        )

    @staticmethod
    def cyclic_coxeter(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n (n>=2), generated by adjacent transpositions plus cyclic transposition.

        It has n generators: (0,1), (1,2), ..., (n-2,n-1), (0,n-1).
        """
        assert n >= 2
        generators = _create_coxeter_generators(n) + [transposition(n, 0, n - 1)]
        generator_names = [f"({i},{i + 1})" for i in range(n - 1)] + [f"(0,{n - 1})"]
        central_state = list(range(n))
        name = f"cyclic_coxeter-{n}"
        return CayleyGraphDef.create(
            generators, central_state=central_state, generator_names=generator_names, name=name
        )

    @staticmethod
    def pancake(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n (n>=2), generated by reverses of all prefixes.

        It has n-1 generators denoted R1,R2..R(n-1), where Ri is reverse of elements 0,1..i.
        See https://en.wikipedia.org/wiki/Pancake_graph.
        """
        assert n >= 2
        generators = []
        generator_names = []
        for prefix_len in range(2, n + 1):
            perm = list(range(prefix_len - 1, -1, -1)) + list(range(prefix_len, n))
            generators.append(perm)
            generator_names.append("R" + str(prefix_len - 1))
        name = f"pancake-{n}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def cubic_pancake(n: int, subset: int) -> CayleyGraphDef:
        """Cayley graph for S_n (n>=2), generated by set of 3 prefix reversal generators.

        Sets definitions are:
          - subset=1 => {Rn, R(n-1), R2}
          - subset=2 => {Rn, R(n-1), R3}
          - subset=3 => {Rn, R(n-1), R(n-2)}
          - subset=4 => {Rn, R(n-1), R(n-3)}
          - subset=5 => {Rn, R(n-2), R2}
          - subset=6 => {Rn, R(n-2), R3}
          - subset=7 => {Rn, R(n-2), R(n-3)}

        where Ri is reverse of elements 0,1..i.
        """

        def pancake_generator(k: int, n: int):
            return list(range(k - 1, -1, -1)) + list(range(k, n, 1))

        assert n >= 2
        assert subset in [1, 2, 3, 4, 5, 6, 7], "subset parameter must be one of {1,2,3,4,5,6,7}"
        generators = []
        generator_names = []
        if subset == 1:
            generators = [pancake_generator(n, n), pancake_generator(n - 1, n), pancake_generator(2, n)]
            generator_names = [f"R{n}", f"R{n-1}", "R2"]
        elif subset == 2:
            generators = [pancake_generator(n, n), pancake_generator(n - 1, n), pancake_generator(3, n)]
            generator_names = [f"R{n}", f"R{n-1}", "R3"]
        elif subset == 3:
            generators = [pancake_generator(n, n), pancake_generator(n - 1, n), pancake_generator(n - 2, n)]
            generator_names = [f"R{n}", f"R{n-1}", f"R{n-2}"]
        elif subset == 4:
            generators = [pancake_generator(n, n), pancake_generator(n - 1, n), pancake_generator(n - 3, n)]
            generator_names = [f"R{n}", f"R{n-1}", f"R{n-3}"]
        elif subset == 5:
            generators = [pancake_generator(n, n), pancake_generator(n - 2, n), pancake_generator(2, n)]
            generator_names = [f"R{n}", f"R{n-2}", "R2"]
        elif subset == 6:
            generators = [pancake_generator(n, n), pancake_generator(n - 2, n), pancake_generator(3, n)]
            generator_names = [f"R{n}", f"R{n-2}", "R3"]
        elif subset == 7:
            generators = [pancake_generator(n, n), pancake_generator(n - 2, n), pancake_generator(n - 3, n)]
            generator_names = [f"R{n}", f"R{n-2}", f"R{n-3}"]
        name = f"cubic_pancake-{n}-{subset}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def burnt_pancake(n: int) -> CayleyGraphDef:
        """Cayley graph generated by reverses of all signed prefixes.

        Actually is a graph for S_2n (n>=1) representing a graph for n pancakes, where i-th element represents bottom
        side of i-th pancake, and (n+i)-th element represents top side of i-th pancake. The graph has n generators
        denoted R1,R2..R(n), where Ri is reverse of elements 0,1..i,n,n+1..n+i."""
        assert n >= 1
        generators = []
        generator_names = []
        for prefix_len in range(0, n):
            perm = []
            perm += list(range(n + prefix_len, n - 1, -1))
            perm += list(range(prefix_len + 1, n, 1))
            perm += list(range(prefix_len, -1, -1))
            perm += list(range(n + prefix_len + 1, 2 * n, 1))
            generators.append(perm)
            generator_names.append("R" + str(prefix_len + 1))
        name = f"burnt_pancake-{n}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(2 * n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def three_cycles(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n (n ≥ 3), generated by all 3-cycles (a, b, c) where a < b, a < c."""
        assert n >= 3
        generators = []
        generator_names = []
        for a, b, c in permutations(range(n), 3):
            if a < b and a < c:
                generators.append(permutation_from_cycles(n, [[a, b, c]]))
                generator_names.append(f"({a} {b} {c})")
        name = f"three_cycles-{n}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def three_cycles_0ij(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n (n ≥ 3), generated by 3-cycles of the form (0 i j), where i != j."""
        generators = []
        generator_names = []
        for i, j in permutations(range(1, n), 2):
            generators.append(permutation_from_cycles(n, [[0, i, j]]))
            generator_names.append(f"({0} {i} {j})")
        name = f"three_cycles_0ij-{n}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def three_cycles_01i(n: int, add_inverses: bool = True) -> CayleyGraphDef:
        """Cayley graph for A_n (n>=3), generated by cycles (0 1 i) for 2<=i<n.

        :param n: Size of permutations.
        :param add_inverses: Whether inverse cycles are added when generating the graph.
        """
        assert n >= 3
        generators = []
        generator_names = []
        for i in range(2, n):
            perm = permutation_from_cycles(n, [[0, 1, i]])
            generators.append(perm)
            generator_names.append(f"(0 1 {i})")
            if add_inverses:
                generators.append(inverse_permutation(perm))
                generator_names.append(f"(1 0 {i})")
        name = f"three_cycles_01i-{n}"
        if add_inverses:
            name += "-ic"  # Inverse closed.
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def derangements(n: int) -> CayleyGraphDef:
        """Cayley graph generated by permutations without fixed points, called derangements."""
        assert n >= 2
        generators = []
        generator_names = []
        for idx, perm in enumerate(permutations(range(n))):
            has_fixed_point = any(perm[i] == i for i in range(n))
            if not has_fixed_point:
                generators.append(list(perm))
                generator_names.append(f"D{idx}")
        name = f"derangements-{n}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def involutive_derangements(n: int) -> CayleyGraphDef:
        """Cayley graph generated by involutive derangements."""
        assert n >= 2 and n % 2 == 0

        generators = []
        generator_names = []

        def generate_matchings(elements):
            if len(elements) == 0:
                return [[]]
            if len(elements) == 2:
                return [[(elements[0], elements[1])]]

            result = []
            first = elements[0]
            for i in range(1, len(elements)):
                partner = elements[i]
                remaining = elements[1:i] + elements[i + 1 :]
                for matching in generate_matchings(remaining):
                    result.append([(first, partner)] + matching)
            return result

        matchings = generate_matchings(list(range(n)))
        for idx, matching in enumerate(matchings):
            perm = list(range(n))
            for a, b in matching:
                perm[a], perm[b] = perm[b], perm[a]
            generators.append(perm)
            generator_names.append(f"ID{idx + 1}")

        name = f"involutive-derangements-{n}"

        return CayleyGraphDef.create(
            generators,
            central_state=list(range(n)),
            generator_names=generator_names,
            name=name,
        )

    @staticmethod
    def stars(n: int) -> CayleyGraphDef:
        """Cayley graph generated by stars permutations."""
        assert n >= 3
        generators = []
        generator_names = []
        for i in range(1, n):
            generators.append(transposition(n, 0, i))
            generator_names.append(f"S{i}")
        name = f"stars-{n}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def generalized_stars(n: int, k: int = 1) -> CayleyGraphDef:
        """Cayley graph generated by generalized star permutations.
        Builds transpositions swapping each of the first k indices with each of the
        remaining n-k indices, i.e. (i <-> j) for i in [0, k-1], j in [k, n-1].
        """
        assert n >= 3
        assert 1 <= k < n

        generators = []
        generator_names = []
        for i in range(k):
            for j in range(k, n):
                generators.append(transposition(n, i, j))
                generator_names.append(f"S{i}-{j}")

        name = f"generalized-stars-{n}-{k}"
        return CayleyGraphDef.create(
            generators,
            central_state=list(range(n)),
            generator_names=generator_names,
            name=name,
        )

    @staticmethod
    def rapaport_m1(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n with M1 generators.

        Reference: E. Rapaport-Strasser. Cayley color groups and hamilton lines. Scr. Math, 24:51–58, 1959.
        """
        generators = []
        generator_names = []

        # Generator 1: Transpositions: (0,1), (0,1)(2,3), (0,1)(2,3)(4,5),...
        for num_pairs in range(1, (n // 2) + 1):
            cycles = []
            for idx in range(num_pairs):
                if 2 * idx + 1 < n:
                    cycles.append([2 * idx, 2 * idx + 1])
            permutation = permutation_from_cycles(n, cycles)
            generators.append(permutation)
            generator_names.append(f"M1_0_{num_pairs}")

        # Generator 2: Transpositions: (1,2), (1,2)(3,4), (1,2)(3,4)(5,6),...
        for num_pairs in range(1, ((n - 1) // 2) + 1):
            cycles = []
            permutation = list(range(n))
            for idx in range(num_pairs):
                if 1 + 2 * idx + 1 < n:
                    cycles.append([1 + 2 * idx, 1 + 2 * idx + 1])
            permutation = permutation_from_cycles(n, cycles)
            generators.append(permutation)
            generator_names.append(f"M1_1_{num_pairs}")

        name = f"rapaport_m1-{n}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def rapaport_m2(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n with M2 generators.

        Reference: E. Rapaport-Strasser. Cayley color groups and hamilton lines. Scr. Math, 24:51–58, 1959.
        """
        # Generator 1: Transposition (0,1)
        g1 = transposition(n, 0, 1)

        # Generator 2: Product of transpositions (0,1)(2,3)...
        g2 = list(range(n))
        for i in range(0, n - 1, 2):
            g2[i], g2[i + 1] = g2[i + 1], g2[i]

        # Generator 3: Product of transpositions (1,2)(3,4)...
        g3 = list(range(n))
        for i in range(1, n - 1, 2):
            g3[i], g3[i + 1] = g3[i + 1], g3[i]

        generators = [g1, g2, g3]
        generator_names = ["(0,1)", "EvenDisjTrans", "OddDisjTrans"]

        name = f"rapaport_m2-{n}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def all_cycles(n: int) -> CayleyGraphDef:
        """Cayley graph for S_n (n ≥ 2), generated by all cycles of length 2 to n."""
        assert n >= 2
        generators = []
        generator_names = []

        for k in range(2, n + 1):
            for subset in combinations(range(n), k):
                min_elem = min(subset)
                rest = [x for x in subset if x != min_elem]

                for perm in permutations(rest):
                    cycle = list(range(n))
                    current = min_elem
                    for target in perm:
                        cycle[current] = target
                        current = target
                    cycle[current] = min_elem

                    generators.append(cycle)
                    generator_names.append(f"cycle_{len(generators)}")

        name = f"all_cycles-{n}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def wrapped_k_cycles(n: int, k: int) -> CayleyGraphDef:
        """
        Cayley graph for S_n (n >= 2, 2 <= k <= n), generated by all consecutive k-cycles with wrap-around.
        """
        assert n >= 2 and 2 <= k <= n, "Need n >= 2 and 2 <= k <= n"
        generators = []
        generator_names = []
        for start in range(n):
            cycle = [(start + j) % n for j in range(k)]
            generators.append(permutation_from_cycles(n, [cycle]))
            generator_names.append(f"({' '.join(map(str, cycle))})")
        name = f"wrapped_k_cycles-{n}-{k}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def larx(n: int) -> CayleyGraphDef:
        """
        Cayley graph for S_n (n >= 2), generated by transposition-based permutations.
        Creates two generators: one with 0,1 transposition and one with cyclic shift.
        """
        assert n >= 2, "Need n >= 2"
        generators = []
        generator_names = []
        perm1 = [1, 0] + list(range(2, n))
        generators.append(perm1)
        generator_names.append(f"({' '.join(map(str, perm1))})")
        perm2 = [0] + list(range(2, n)) + [1]
        generators.append(perm2)
        generator_names.append(f"({' '.join(map(str, perm2))})")
        name = f"larx-{n}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def increasing_k_cycles(n: int, k: int) -> CayleyGraphDef:
        """
        Cayley graph for S_n generated by all increasing k-cycles (c_1 c_2 ... c_k)
        with 0 <= c_1 < c_2 < ... < c_k < n.
        """
        assert n >= 1 and 1 <= k <= n, "n must be >= 1 and 1 <= k <= n"

        generators = []
        generator_names = []

        for combo in combinations(range(n), k):
            cyc = list(combo)
            generators.append(permutation_from_cycles(n, [cyc]))
            generator_names.append(f"({','.join(map(str, cyc))})")

        name = f"increasing_k_cycles-{n}-{k}"
        return CayleyGraphDef.create(
            generators,
            central_state=list(range(n)),
            generator_names=generator_names,
            name=name,
        )

    @staticmethod
    def sheveleva2(n: int, k: int) -> CayleyGraphDef:
        """
        "Sheveleva2" generators consist of only 2 elements and have two parameters: n and k.

        One generator (A) is always an involution. The other (S) is a product of transpositions and one 4-cycle.

        The construction is as follows:

        1. Starting with 0, transpositions (i, i+1) are created.
        2. These transpositions are assigned to generators one by one. The first transposition (0,1) is assigned to one
           generator, the second (1,2) to another, the third (2,3) to the first again, and so on.
        3. When the process reaches index k, a 4-cycle (k-1, k, k+1, k+2) is created, which is added to the current
           generator.
        4. After this, the alternate creation and assignment continues. transpositions (i, i+1).
        5. The process stops when n is reached.
        6. The final generators are obtained by multiplying all the permutations assigned to them.

        :param n: length of permutations.
        :param k: additional parameter, "square position".
        """
        assert 1 <= k <= n - 3, "k must be >= 1 and <= n - 3"

        p1 = permutation_from_cycles(n, [[i, i + 1] for i in range(0, n - 1, 2)])
        p2 = permutation_from_cycles(n, [[i, i + 1] for i in range(1, n - 1, 2)])
        if k % 2 == 1:
            if k == n - 3:
                p1[k - 1] = k
                p1[k] = k + 1
                p1[k + 1] = k + 2
                p1[k + 2] = k - 1
                p2[k] = k
                p2[k + 1] = k + 1
                p2[k + 2] = k + 2
            else:
                p1[k - 1] = k
                p1[k] = k + 1
                p1[k + 1] = k + 2
                p1[k + 2] = k - 1
                p2[k] = k
                p2[k + 1] = k + 3
                p2[k + 2] = k + 2
                p2[k + 3] = k + 1
        else:
            if k == n - 3:
                p2[k - 1] = k
                p2[k] = k + 1
                p2[k + 1] = k + 2
                p2[k + 2] = k - 1
                p1[k] = k
                p1[k + 1] = k + 1
                p1[k + 2] = k + 2
            else:
                p2[k - 1] = k
                p2[k] = k + 1
                p2[k + 1] = k + 2
                p2[k + 2] = k - 1
                p1[k] = k
                p1[k + 1] = k + 3
                p1[k + 2] = k + 2
                p1[k + 3] = k + 1
        if k % 2 == 1:
            generators = [p2, p1]
        else:
            generators = [p1, p2]
        generator_names = ["A", "S"]
        name = f"sheveleva2-n{n}-k{k}"
        return CayleyGraphDef.create(
            generators, central_state=list(range(n)), generator_names=generator_names, name=name
        )

    @staticmethod
    def consecutive_k_cycles(n: int, k: int) -> CayleyGraphDef:
        """
        Cayley graph for S_n generated by all consecutive k-cycles:
        (i, i+1, ..., i+k-1) for i = 0..n-k.
        """
        assert n >= 1 and 1 <= k <= n, "n must be >= 1 and 1 <= k <= n"

        generators = []
        generator_names = []

        for i in range(n - k + 1):
            cyc = list(range(i, i + k))
            generators.append(permutation_from_cycles(n, [cyc]))
            generator_names.append(f"({','.join(map(str, cyc))})")

        name = f"consecutive_k_cycles-{n}-{k}"
        return CayleyGraphDef.create(
            generators,
            central_state=list(range(n)),
            generator_names=generator_names,
            name=name,
        )

    @staticmethod
    def conjugacy_classes(n: int, classes: dict[tuple[int], Union[int, None]]) -> CayleyGraphDef:
        """
        A conjugacy class of S_n is a subset of permutations with same set of cycle lengths.

        Each entry (key, value) of `classes` dict specifies a conjugacy class:
            key, tuple[int]: cycle lengths, contains positive integers, the order does not matter, e.g.
                (4,3,3) class have 2 cycles of length 3 (3-cycle) and one 4-cycle.
                sum(key) must be <= n; if sum(key) < n, the remaining elements are treated as 1-cycles (fixed elements).
            value, int or None: the number of generators randomly sampled from the class specified by key.
                If None, all permutations are taken.

        Examples:

        n = 6, classes = {(3,2): None}:
            takes all permutations from S_6 with one 3-cycles, one 2-cycle, and one fixed element.

        n = 8, classes = {(3,2,3): None}:
            takes all permutations from S_8 with two 3-cycles and one 2-cycle.

        n = 9, classes = {(4,): None}:
            takes all permutations from S_9 with one 4-cycle and five fixed elements.

        n = 23, classes = {(1,3,1,5,3,5,4,1): 3}:
            takes three random permutations from S_23 with two 3-cycles, one 4-cycle, two 5-cycles, and three 1-cycles.

        n = 4, classes = {(2,2): None, (3,): 5}:
            takes all permutations from S_4 with two 2-cycles and 5 random permutations with one 3-cycle.

        n = 10, classes = {(3,3,4): None, (1,1,2,2,2): None, (10,): 2}
            takes all permutations from S_10 with two 3-cycles and one 4-cycle,
            all permutations three 2-cycles and four fixed elemens,
            and 2 random permutations with one 10-cycle.

        N.B. The set of cycle lengths of a permutation from S_n forms a partition of n (https://oeis.org/A000041)
        """
        assert n >= 1, "n must be >= 1"
        assert all(
            all(cl > 0 for cl in cycle_lengths) for cycle_lengths in classes
        ), "All cycle lengths must be positive"
        assert all(sum(cycle_lengths) <= n for cycle_lengths in classes), "Sum of cycle lengths must be <= n"

        generators = []
        generator_names = []
        name_strs = []
        for cycle_lengths, n_samples in classes.items():
            lengths = list(cycle_lengths)
            cycles_sum = sum(lengths)
            while cycles_sum < n:
                lengths.append(1)
                cycles_sum += 1

            lengths = sorted(lengths, reverse=True)
            name = ",".join(map(str, lengths))
            if n_samples is None:
                for i, perm in enumerate(permutations_with_cycle_lenghts(n, lengths)):
                    generators.append(perm)
                    generator_names.append(f"({','.join(map(str, lengths))})_{i + 1}")
            else:
                name += f"_{n_samples}"
                for i in range(n_samples):
                    generators.append(partition_to_permutation(lengths, True))
                    generator_names.append(f"({','.join(map(str, lengths))})_{i + 1}")
            name_strs.append(name)

        name = f"conjugacy_class-{n}-{'-'.join(name_strs)}"
        return CayleyGraphDef.create(
            generators,
            central_state=list(range(n)),
            generator_names=generator_names,
            name=name,
        )

    @staticmethod
    def rand_generators(n: int, k: int) -> CayleyGraphDef:
        """
        Cayley graph for S_n generated by k random permutations
        """
        assert n >= 1, "n must be >= 1"
        assert k >= 1, "k must be >= 1"
        assert k <= factorial(n), "k must be <= n!"

        generators = []
        generator_names = []
        perm = np.arange(n)
        perm_set = set()
        counter = 0
        while counter < k:
            np.random.shuffle(perm)
            if tuple(perm) not in perm_set:
                counter += 1
                perm_set.add(tuple(perm))
                generators.append(perm.tolist())
                generator_names.append(f"({','.join(map(str, perm))})")

        name = f"rand_generators-{n}-{k}"
        return CayleyGraphDef.create(
            generators,
            central_state=list(range(n)),
            generator_names=generator_names,
            name=name,
        )

    @staticmethod
    def down_cycles(n: int) -> CayleyGraphDef:
        """
        Cayley graph generated by all downcycles in S_n:
        (i, i+1, ..., j), 0 <= i < j < n.
        """
        assert n >= 2, "n must be >= 2"

        generators = []
        generator_names = []

        for i in range(n):
            for j in range(i + 1, n):
                cycle = list(range(i, j + 1))
                generators.append(permutation_from_cycles(n, [cycle]))
                generator_names.append(f"({','.join(map(str, cycle))})")

        name = f"down_cycles-{n}"
        return CayleyGraphDef.create(
            generators,
            central_state=list(range(n)),
            generator_names=generator_names,
            name=name,
        )


def prepare_graph(name: str, n: int = 0, **kwargs) -> CayleyGraphDef:
    """Returns pre-defined CayleyGraphDef by codename and additional kwargs.

    See the source of this function for list of supported graphs.
    """
    if name == "cube_2/2/2_6gensQTM":
        return Puzzles.rubik_cube(2, "fixed_QTM")
    elif name == "cube_2/2/2_9gensHTM":
        return Puzzles.rubik_cube(2, "fixed_HTM")
    elif name == "cube_3/3/3_12gensQTM":
        return Puzzles.rubik_cube(3, "QTM")
    elif name == "cube_3/3/3_18gensHTM":
        return Puzzles.rubik_cube(3, "HTM")
    elif name == "mini_pyramorphix":
        return Puzzles.mini_pyramorphix()
    elif name == "pyraminx":
        return Puzzles.pyraminx()
    elif name == "hungarian_rings":
        hr_params = get_santa_parameters_from_n(n)
        return Puzzles.hungarian_rings(*hr_params)
    elif name == "starminx":
        return Puzzles.starminx()
    elif name == "starminx_2":
        return Puzzles.starminx_2()
    elif name == "megaminx":
        return Puzzles.megaminx()
    elif name == "lx":
        return PermutationGroups.lx(n)
    elif name.startswith("lx-"):
        return PermutationGroups.lrx(int(name[3:]))
    elif name == "lrx":
        return PermutationGroups.lrx(n)
    elif name.startswith("lrx-"):
        return PermutationGroups.lrx(int(name[4:]))
    elif name == "top_spin":
        return PermutationGroups.top_spin(n)
    elif name == "all_transpositions":
        return PermutationGroups.all_transpositions(n)
    elif name == "transposons":
        return PermutationGroups.transposons(n)
    elif name == "block_interchange":
        return PermutationGroups.block_interchange(n)
    elif name == "full_reversals":
        return PermutationGroups.full_reversals(n)
    elif name == "coxeter":
        return PermutationGroups.coxeter(n)
    elif name == "pancake":
        return PermutationGroups.pancake(n)
    elif name == "all_cycles":
        return PermutationGroups.all_cycles(n)
    elif name == "larx":
        return PermutationGroups.larx(n)
    elif name == "01i":
        return PermutationGroups.three_cycles_01i(n)
    elif name == "increasing_k_cycles":
        return PermutationGroups.increasing_k_cycles(n, int(kwargs["k"]))
    elif name == "consecutive_k_cycles":
        return PermutationGroups.consecutive_k_cycles(n, int(kwargs["k"]))
    elif name == "conjugacy_class":
        return PermutationGroups.conjugacy_classes(n, kwargs["classes"])
    elif name == "rand_generators":
        return PermutationGroups.rand_generators(n, int(kwargs["k"]))
    elif name == "down_cycles":
        return PermutationGroups.down_cycles(n)
    else:
        raise ValueError(f"Unknown generator set: {name}")


class MatrixGroups:
    """Pre-defined Cayley graphs for matrix groups."""

    @staticmethod
    def heisenberg(
        *,
        n: int = 3,
        modulo: int = 0,
        add_inverses: bool = True,
    ) -> CayleyGraphDef:
        """Returns Cayley graph for the Heisenberg group.

        For ``n=3``, this is a group of upper triangular 3x3 integer matrices with 1s on main diagonal.
        See https://en.wikipedia.org/wiki/Heisenberg_group. Generated by 4 matrices: x=(110,010,001), y=(100,011,001),
        and their inverses.

        For ``n>=4``, this is a group of ``n*n`` matrices which differ from identity matrix only in top row or right
        column. See https://en.wikipedia.org/wiki/Heisenberg_group#Higher_dimensions.

        The number of generators is ``4(n-2)`` when inverses are added or ``2(n-2)`` when inverses are not added.

        Central element is identity matrix.

        :param n: Size of the matrix. Defaults to 3.
        :param modulo: multiplication modulo (or 0 if multiplication is not modular). Defaults to 0.
        :param add_inverses: whether to add inverse generators. Defaults to ``True``.
        :return: requested graph as ``CayleyGraphDef``.
        """
        assert n >= 3
        generators = []
        generator_names = []
        for i in range(1, n - 1):
            mx = np.eye(n, dtype=np.int64)
            mx[0][i] = 1
            generators.append(MatrixGenerator(mx, modulo=modulo))
            generator_names.append("x" if n == 3 else f"x{i}")
        for i in range(1, n - 1):
            mx = np.eye(n, dtype=np.int64)
            mx[i][n - 1] = 1
            generators.append(MatrixGenerator(mx, modulo=modulo))
            generator_names.append("y" if n == 3 else f"y{i}")

        name = f"heisenberg-{n}"
        if modulo > 0:
            name += f"%{modulo}"
        graph_def = CayleyGraphDef.for_matrix_group(
            generators=generators,
            generator_names=generator_names,
            name=name,
        )
        if add_inverses:
            graph_def = graph_def.make_inverse_closed()
        return graph_def

    @staticmethod
    def special_linear_fundamental_roots(n: int, modulo: int = 0) -> CayleyGraphDef:
        """Returns Cayley graph for the special linear group SL(n, Z/mZ).

        This is a group of n x n integer matrices with determinant 1, modulo m.

        Generated by n-1 fundamental roots: e_i = (e_ij) where e_ij is 1 at (i,j) and 0 elsewhere,
        and their negatives.
        Central element is identity matrix.

        :param n: Size of matrices.
        :param modulo: multiplication modulo (or 0 if multiplication is not modular).
        :return: requested graph as `CayleyGraphDef`.
        """
        assert n >= 2
        generators = []
        generator_names = []
        for k in range(n - 1):
            e = MatrixGenerator.create(
                [[1 if j == i or (i == k and j == k + 1) else 0 for j in range(n)] for i in range(n)], modulo=modulo
            )
            f = MatrixGenerator.create(
                [[1 if j == i or (i == k + 1 and j == k) else 0 for j in range(n)] for i in range(n)], modulo=modulo
            )
            generators.extend([e, e.inv, f, f.inv])
            generator_names.extend([f"e{k + 1}", f"e{k + 1}'", f"f{k + 1}", f"f{k + 1}'"])
        name = f"sl_fund_roots-{n}"
        if modulo > 0:
            name += f"%{modulo}"
        return CayleyGraphDef.for_matrix_group(generators=generators, generator_names=generator_names, name=name)

    @staticmethod
    def special_linear_root_weyl(n: int, modulo: int = 0) -> CayleyGraphDef:
        """Returns Cayley graph for the special linear group SL(n, Z/mZ).

        This is a group of n x n integer matrices with determinant 1, modulo m.

        Generated by a single root element e_12 and a lift of a Coxeter element w.
        Central element is identity matrix.

        :param n: Size of matrices.
        :param modulo: multiplication modulo (or 0 if multiplication is not modular).
        :return: requested graph as `CayleyGraphDef`.
        """
        assert n >= 2
        e_entries = [[1 if j == i else 0 for j in range(n)] for i in range(n)]
        e_entries[0][1] = 1
        e = MatrixGenerator.create(e_entries, modulo=modulo)
        w_entries = [[1 if j == i + 1 else 0 for j in range(n)] for i in range(n)]
        w_entries[n - 1][0] = (-1) ** (n - 1)
        w = MatrixGenerator.create(w_entries, modulo=modulo)
        w_inv_entries = [[w_entries[j][i] for j in range(n)] for i in range(n)]
        w_inv = MatrixGenerator.create(w_inv_entries, modulo=modulo)
        name = f"sl_root_weyl-{n}"
        if modulo > 0:
            name += f"%{modulo}"
        return CayleyGraphDef.for_matrix_group(
            generators=[e, e.inv, w, w_inv],
            generator_names=["e", "e'", "w", "w'"],
            name=name,
        )
